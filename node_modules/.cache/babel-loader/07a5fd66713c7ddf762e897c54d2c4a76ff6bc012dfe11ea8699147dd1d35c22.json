{"ast":null,"code":"import scoreTable from \"../data/scoreTable.json\";\nimport pokemonTypes from \"../data/pokemonTypes.json\";\n\n// ---------- Function do calculate the results of the better ranked types/habitas based on the scoreTable for each option selected by the user ---------- //\nexport const getResults = formAnswers => {\n  // ----- Initializing the score for each type/habitat -----\n  // const score = [\n  // \t{\n  // \t\ttype_habitat: 'bug',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'dragon',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'electric',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'fairy',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'fighting',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'fire',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'flying',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'ghost',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'grass',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'ground',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'ice',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'normal',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'poison',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'psychic',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'rock',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'steel',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'water',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'cave',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'forest',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'grassland',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'mountain',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'roughTerrain',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'sea',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'urban',\n  // \t\tvalue: 0,\n  // \t},\n  // \t{\n  // \t\ttype_habitat: 'waterEdges',\n  // \t\tvalue: 0,\n  // \t}\n  // ];\n  const score = {};\n  pokemonTypes.forEach(type => {\n    score[type] = 0;\n  });\n  console.log(formAnswers);\n  Object.entries(formAnswers).forEach(([question, answer]) => {\n    console.log(question, answer);\n    const questionInfo = scoreTable.find(q => q.question === question);\n    if (!questionInfo) return;\n    // console.log('questionInfo', questionInfo);\n\n    const answerInfo = questionInfo.answers.find(a => a.value === answer);\n    if (!answerInfo) return;\n    // console.log('asnwerInfo', answerInfo);\n\n    Object.entries(answerInfo.points).forEach(([type, points]) => {\n      // console.log(type, points)\n      score[type] += points;\n      // console.log(score[type]);\n    });\n  });\n  console.log(score);\n  // ----- Iterating through the user's answers to calculate the results for type/habitat -----\n  // for (let answerTitle in formAnswers) {\n  // \t// ----- Finding the index of the matching question inside the scoreTable -----\n  // \tlet indexOfScoreInfo = scoreTable.findIndex(scoreInfo => scoreInfo.question === answerTitle);\n  // \t// ----- The 'color' question will return an index of -1 because it's not contained in the scoreTable. So we'll not consider it -----\n  // \tif (indexOfScoreInfo >= 0) {\n  // \t\t// ----- Finding the index of the matching answer inside the current question -----\n  // \t\tlet indexOfAnswer = scoreTable[indexOfScoreInfo].answers.findIndex(answerScore => answerScore.value === formAnswers[answerTitle]);\n  // \t\t// ----- Accessing that answer to check the scores defined for it -----\n  // \t\tlet scoresList = scoreTable[indexOfScoreInfo].answers[indexOfAnswer].points;\n  // \t\t// ----- Iterating through each answer score to update the user's score for each type/habitat -----\n  // \t\tfor (let scoreItem in scoresList) { \n  // \t\t\t// ----- Finding the index matching the current type/habitat score -----\n  // \t\t\tconst scoreIndex = score.findIndex(item => item.type_habitat === scoreItem);\n  // \t\t\t// ----- Updating the user's score -----\n  // \t\t\tscore[scoreIndex].value += scoresList[scoreItem];\n  // \t\t}\n  // \t}\n  // }\n\n  // ----- Sorting the user's score from highest to lowest -----\n  // score.sort(function (a, b) {\n  // \tif (b.value > a.value) {\n  // \t  return 1;\n  // \t}\n  // \tif (b.value < a.value) {\n  // \t  return -1;\n  // \t}\n  // \treturn 0;\n  //   });\n\n  console.log('finalScore', score);\n  return score;\n};","map":{"version":3,"names":["scoreTable","pokemonTypes","getResults","formAnswers","score","forEach","type","console","log","Object","entries","question","answer","questionInfo","find","q","answerInfo","answers","a","value","points"],"sources":["C:/Moana_SSD/WebDev/Projetos/pokebuzz/src/services/results.jsx"],"sourcesContent":["\r\nimport scoreTable from \"../data/scoreTable.json\"\r\nimport pokemonTypes from \"../data/pokemonTypes.json\";\r\n\r\n// ---------- Function do calculate the results of the better ranked types/habitas based on the scoreTable for each option selected by the user ---------- //\r\nexport const getResults = (formAnswers) => {\r\n\r\n\t// ----- Initializing the score for each type/habitat -----\r\n\t// const score = [\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'bug',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'dragon',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'electric',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'fairy',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'fighting',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'fire',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'flying',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'ghost',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'grass',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'ground',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'ice',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'normal',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'poison',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'psychic',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'rock',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'steel',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'water',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'cave',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'forest',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'grassland',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'mountain',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'roughTerrain',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'sea',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'urban',\r\n\t// \t\tvalue: 0,\r\n\t// \t},\r\n\t// \t{\r\n\t// \t\ttype_habitat: 'waterEdges',\r\n\t// \t\tvalue: 0,\r\n\t// \t}\r\n\t// ];\r\n\tconst score = {};\r\n\r\n\tpokemonTypes.forEach(type => {\r\n\t\tscore[type] = 0;\r\n\t});\r\n \r\n\tconsole.log(formAnswers);\r\n\r\n\tObject.entries(formAnswers).forEach(([question, answer]) => {\r\n\t\tconsole.log(question, answer)\r\n\t\tconst questionInfo = scoreTable.find(q => q.question === question);\r\n\t\tif (!questionInfo) return\r\n\t\t// console.log('questionInfo', questionInfo);\r\n\r\n\t\tconst answerInfo = questionInfo.answers.find(a => a.value === answer);\r\n\t\tif (!answerInfo) return\r\n\t\t// console.log('asnwerInfo', answerInfo);\r\n\r\n\t\tObject.entries(answerInfo.points).forEach(([type, points]) => {\r\n\t\t\t// console.log(type, points)\r\n\t\t\tscore[type] += points;\r\n\t\t\t// console.log(score[type]);\r\n\t\t})\r\n\t})\r\n\r\n\tconsole.log(score);\r\n\t// ----- Iterating through the user's answers to calculate the results for type/habitat -----\r\n\t// for (let answerTitle in formAnswers) {\r\n\t// \t// ----- Finding the index of the matching question inside the scoreTable -----\r\n\t// \tlet indexOfScoreInfo = scoreTable.findIndex(scoreInfo => scoreInfo.question === answerTitle);\r\n\t// \t// ----- The 'color' question will return an index of -1 because it's not contained in the scoreTable. So we'll not consider it -----\r\n\t// \tif (indexOfScoreInfo >= 0) {\r\n\t// \t\t// ----- Finding the index of the matching answer inside the current question -----\r\n\t// \t\tlet indexOfAnswer = scoreTable[indexOfScoreInfo].answers.findIndex(answerScore => answerScore.value === formAnswers[answerTitle]);\r\n\t// \t\t// ----- Accessing that answer to check the scores defined for it -----\r\n\t// \t\tlet scoresList = scoreTable[indexOfScoreInfo].answers[indexOfAnswer].points;\r\n\t// \t\t// ----- Iterating through each answer score to update the user's score for each type/habitat -----\r\n\t// \t\tfor (let scoreItem in scoresList) { \r\n\t// \t\t\t// ----- Finding the index matching the current type/habitat score -----\r\n\t// \t\t\tconst scoreIndex = score.findIndex(item => item.type_habitat === scoreItem);\r\n\t// \t\t\t// ----- Updating the user's score -----\r\n\t// \t\t\tscore[scoreIndex].value += scoresList[scoreItem];\r\n\t// \t\t}\r\n\t// \t}\r\n\t// }\r\n\r\n\t// ----- Sorting the user's score from highest to lowest -----\r\n\t// score.sort(function (a, b) {\r\n\t// \tif (b.value > a.value) {\r\n\t// \t  return 1;\r\n\t// \t}\r\n\t// \tif (b.value < a.value) {\r\n\t// \t  return -1;\r\n\t// \t}\r\n\t// \treturn 0;\r\n\t//   });\r\n\r\n\t  console.log('finalScore', score);\r\n\t  return score;\r\n};\r\n"],"mappings":"AACA,OAAOA,UAAU,MAAM,yBAAyB;AAChD,OAAOC,YAAY,MAAM,2BAA2B;;AAEpD;AACA,OAAO,MAAMC,UAAU,GAAIC,WAAW,IAAK;EAE1C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAMC,KAAK,GAAG,CAAC,CAAC;EAEhBH,YAAY,CAACI,OAAO,CAACC,IAAI,IAAI;IAC5BF,KAAK,CAACE,IAAI,CAAC,GAAG,CAAC;EAChB,CAAC,CAAC;EAEFC,OAAO,CAACC,GAAG,CAACL,WAAW,CAAC;EAExBM,MAAM,CAACC,OAAO,CAACP,WAAW,CAAC,CAACE,OAAO,CAAC,CAAC,CAACM,QAAQ,EAAEC,MAAM,CAAC,KAAK;IAC3DL,OAAO,CAACC,GAAG,CAACG,QAAQ,EAAEC,MAAM,CAAC;IAC7B,MAAMC,YAAY,GAAGb,UAAU,CAACc,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACJ,QAAQ,KAAKA,QAAQ,CAAC;IAClE,IAAI,CAACE,YAAY,EAAE;IACnB;;IAEA,MAAMG,UAAU,GAAGH,YAAY,CAACI,OAAO,CAACH,IAAI,CAACI,CAAC,IAAIA,CAAC,CAACC,KAAK,KAAKP,MAAM,CAAC;IACrE,IAAI,CAACI,UAAU,EAAE;IACjB;;IAEAP,MAAM,CAACC,OAAO,CAACM,UAAU,CAACI,MAAM,CAAC,CAACf,OAAO,CAAC,CAAC,CAACC,IAAI,EAAEc,MAAM,CAAC,KAAK;MAC7D;MACAhB,KAAK,CAACE,IAAI,CAAC,IAAIc,MAAM;MACrB;IACD,CAAC,CAAC;EACH,CAAC,CAAC;EAEFb,OAAO,CAACC,GAAG,CAACJ,KAAK,CAAC;EAClB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEEG,OAAO,CAACC,GAAG,CAAC,YAAY,EAAEJ,KAAK,CAAC;EAChC,OAAOA,KAAK;AACf,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}